load("swirl")
history()
install.packages("swirl")
install.packages("httr")
install.packages("curl")
install.packages("curl")
install.packages("curl")
install.packages("httr")
install.packages("swirl")
install.packages("testhat")
quit()
f  <- function(a,b){}
f  <- function(a,b){
a^2
}
f(2)
f(2,3)
#lazy evaluation
f <- function(a,b){
print(a)
print(b)
}
f(4)
f <- function(a,b=5){
print(a)
print(b)
}
f(4)
f(4,10)
args(paste)
args(paste)
args(cat)
lm
path()
path
workspace()
search()
.GlobalEnv
.GlobalEnv()
print(.GlobalEnv)
search("lm")
search(lm)
swirl()
swirl
library(swirl)
ls()
rm("f")
ls()
f3 <- function(x,y){
x^2 + y/z
}
f(1,2)
f3(1,2)
z = 4
f3(1,2)
globalenv()
globalenv
globalenv()
wd()
cwd()
getwd()
setwd("/media/horus/stock/GitRepos.dir/coursera_dataanalysis.dir/dataAnalysisCoursera/Rprogramming.dir/Week2.dir/")
source("myfirstfunctions.r")
cube <- make.power(3)
square <- make.power(2)
cube(3)
square(3)
ls(environment(cube))
ls(environment(globalenv))
ls(environment(base))
ls(base)
y <- 10
f < function(x){}
f <- function(x){
y <- 3
y^2+g(x)
}
g <- function(x){}
g <- function(x){
x*y
}
f(3)
make.NegLogLik <- function(data,fixed = c(FALSE,FALSE)){
params <- fixed
function(p){
params[!fixed] <- p
mu <- param[1]
sigma <- params[2]
a <- -0.5*length(data)*log(2*pi*sigma^2)
b <- -0.5*sum((data-mu)^2)/(sigma^2)
-(a+b)
}
}
make.NegLogLik <- function(data,fixed = c(FALSE,FALSE)){
params <- fixed
function(p){
params[!fixed] <- p
mu <- params[1]
sigma <- params[2]
a <- -0.5*length(data)*log(2*pi*sigma^2)
b <- -0.5*sum((data-mu)^2)/(sigma^2)
-(a+b)
}
}
set.seed(1);
normals <- rnorm(100,1,2)
nLL <- make.NegLogLik(normals)
nLL
ls(environment(nLL))
optim(c(mu=0,sigma=1),nLL)$par
optim(c(mu=0,sigma=1),nLL)$par
nLL <- make.NegLogLik(normals,c(FALSE,2))
optimize(nLL,c(-1,3))$minimum
